<!DOCTYPE html>
<html lang="pt-BR">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Criar Documento</title>

  <!-- TinyMCE -->
  <script src="https://cdn.jsdelivr.net/npm/tinymce@6.8.3/tinymce.min.js"></script>

  <!-- Estilos -->
  <link rel="stylesheet" href="style.css">
  <style>
    body             { background-color: rgb(248, 243, 214); padding:20px; font-family:sans-serif; }
    h1               { text-align:center; }
    /* garante que o editor fique atr√°s do modal */
    #editor-container { position: relative; z-index: 1; }    
    textarea#editor  { min-height:500px; }

    .center          { text-align:center; margin-bottom:20px; }
    select,button    { margin:5px; padding:8px 15px; }

    /* Chat Clinbot */
    #clinbotChat     { max-width:1000px; margin:20px auto 0; background:#fff;
                       border:1px solid #ccc; border-radius:8px; padding:15px;
                       white-space:pre-wrap; }
    #clinbotChat .user      { color:#0d6efd; font-weight:600; }
    #clinbotChat .assistant{
  color:#333;                 /* cinza-escuro */
  text-align:justify;
  line-height:1.4;
  margin:12px 0;  
  white-space:normal;         /* permite quebras de linha autom√°ticas */
}
    #clinbotQuestion { width:100%; max-width:1000px; height:80px; margin:10px auto;
                       display:block; padding:10px; }

    /* Painel lateral de transcri√ß√£o */
    .side-panel{
      position:fixed; right:0; top:0; width:340px; height:100%; background:#fff;
      border-left:2px solid #ccc; padding:15px; overflow-y:auto;
      box-shadow:-2px 0 5px rgba(0,0,0,0.1); z-index:2;
    }
    .side-panel h3{margin-top:0; text-align:center;}
  </style>
</head>


<body>
  <h1>üìù Criar Novo Documento</h1>

  <!-- Escolha de pasta e template -->
  <div class="center">
    <label for="tipo">Escolha a pasta:</label>
    <select id="tipo">
      <option value="prontuario">Prontu√°rio</option>
      <option value="resumo">Resumo</option>
      <option value="exame">Exame</option>
      <option value="tratamento">Tratamento</option>
      <option value="documento">Documento</option>
    </select>

  </div>

  <!-- TinyMCE -->
  <div id="editor-container">
    <textarea id="editor"></textarea>
  </div>
  <div id="soapStatus" style="text-align:center; margin:10px 0; display:none; font-style:italic; color:#555;">‚è≥ Gerando SOAP...</div>

<!-- Gravador de √°udio -->
<div class="center" id="audioControls">
  <button id="recordBtn"  onclick="iniciarGravacao()">üéôÔ∏è‚ÄØGravar consulta</button>
  <button id="pauseBtn"   onclick="pausarGravacao()"  hidden>‚è∏Ô∏è‚ÄØPausar</button>
  <button id="resumeBtn"  onclick="retomarGravacao()" hidden>‚ñ∂Ô∏è‚ÄØRetomar</button>
  <button id="stopBtn"    onclick="pararGravacao()"  hidden>‚èπÔ∏è‚ÄØParar</button>
  <span   id="tempoLabel"></span>
</div>

<!-- Painel lateral de transcri√ß√£o -->
<div id="transcribePanel" class="side-panel" hidden>
  <h3>Transcri√ß√£o em Tempo Real</h3>
  <div id="transcriptionContent"></div>
</div>

  <!-- Bot√µes principais -->
  <div class="center">
    <button onclick="salvarDocumento()">üíæ Salvar</button>
    <button onclick="clinbotPrimeiraAnalise()">ü§ñ Clinbot</button>
    <button onclick="voltar()">üîô Voltar</button>
    <button onclick="abrirMedUtis()" style="margin:5px; padding:8px 15px;">üíä med.utis</button>
  </div>

  <!-- √Årea de chat / respostas -->
  <div id="clinbotChat" hidden></div>
  <textarea id="clinbotQuestion" placeholder="Pergunte algo ao Clinbot..." hidden></textarea>
  <div class="center"><button id="clinbotAskBtn" onclick="clinbotPerguntar()" hidden>Enviar pergunta</button></div>

  
  <!-- Firebase + OpenAI + toda a l√≥gica -->
  <script type="module">
    /* ---------- Firebase ---------- */
    import { initializeApp }                          from "https://www.gstatic.com/firebasejs/10.8.1/firebase-app.js";
    import { getFirestore, doc, getDoc, updateDoc }   from "https://www.gstatic.com/firebasejs/10.8.1/firebase-firestore.js";
    import { getStorage, ref, uploadBytes, getDownloadURL }
                                                     from "https://www.gstatic.com/firebasejs/10.8.1/firebase-storage.js";

const firebaseConfig = {
  apiKey:            "AIzaSyAmF5FS_ekWW_7-1RUHtGCR71LH6r9fg08",
  authDomain:        "medcomvc-ubs.firebaseapp.com",
  projectId:         "medcomvc-ubs",
  storageBucket:     "medcomvc-ubs.firebasestorage.app",
  messagingSenderId: "313420248004",
  appId:             "1:313420248004:web:a9a28d97b3ef2e33c36a91"
};

    const app     = initializeApp(firebaseConfig);
    const db      = getFirestore(app);
    const storage = getStorage(app, "gs://medcomvc-ubs.firebasestorage.app");

    /* ---------- Templates ---------- */
    const TEMPLATE_GERAL      = "assets/templates/template_geral.html";
    const TEMPLATE_TRATAMENTO = "assets/templates/template_tratamento.html";

    /* ---------- BASE da API ----------
   ‚Ä¢ Usa 127.0.0.1 apenas se voc√™ estiver rodando localmente.
   ‚Ä¢ Para QUALQUER outro hostname (inclusive www.med.com.vc), usa o backend p√∫blico. */
   const API_BASE =
  (["localhost", "127.0.0.1"].includes(window.location.hostname))
    ? "http://127.0.0.1:8000"
    : "https://api.med.com.vc";



    /* ---------- Vari√°veis globais ---------- */
    const pacienteId = localStorage.getItem("pacienteSelecionado");
    const medicoId   = localStorage.getItem("uid");

    /* ---------- Aplica preset de pasta se vier na URL ---------- */
    const preset = new URLSearchParams(window.location.search).get('preset');
    if (preset) {
      const tipoSel = document.getElementById('tipo');
      if (tipoSel && [...tipoSel.options].some(o => o.value === preset)) {
        tipoSel.value = preset;
      }
    }

    /* ---------- Abrir med.utis + aba de receita ---------- */
    window.abrirMedUtis = () => {
      /* 1) miniapp med.utis */
      /* 2) nova aba deste mesmo editor j√° com "tratamento" pr√©‚Äëselecionado */
      const url = new URL(window.location.href);
      url.searchParams.set('preset', 'tratamento');
      window.open(url.toString(), '_blank');
      window.open('./MedUtis/index.html', '_blank');
    };

    // Fun√ß√£o para abrir automaticamente abas com preset
    function abrirAutoTab(preset) {
      const url = new URL(window.location.href);
      url.searchParams.set('preset', preset);
      window.open('./criar_doc.html?' + url.searchParams.toString(), '_blank');
    }

    /* ---------- Hist√≥rico de conversa (Clinbot) ---------- */
    const conversation = []; // {role:"user"/"assistant", content:"..."}

    /* ---------- √Åudio / Transcri√ß√£o ---------- */
    let recordingDone = false;
    let mediaRecorder   = null;
    let isPaused        = false;
    let cronometro      = null;
    let transcriptChunks = [];   // Armazena todos os textos j√° transcritos
    let summaryCounter  = 0;   // Conta quantas transcri√ß√µes ocorreram
    let keepCycling = false;      // controla se deve continuar gerando blobs
    let audioBuffer     = [];    // Buffer em tempo real para o √∫ltimo chunk
    let soapTimeout     = null;  // Usado para garantir 1 chamada SOAP por chunk

/* === formato bonito para a resposta do Clinbot === */
function formatAssistant(t){
  // negrito: **texto** ‚Üí <strong>texto</strong>
  t = t.replace(/\*\*(.+?)\*\*/g, "<strong>$1</strong>");

  // sublinhado: *texto* ‚Üí <u>texto</u>
  t = t.replace(/\*(?!\*)([^*]+?)\*(?!\*)/g, "<u>$1</u>");

  const lines = t.split(/\r?\n/);
  let html = "", list=null;            // list = null | 'ul' | 'ol'

  const closeList = () => { if(list){ html += `</${list}>`; list=null;} };

  for (let raw of lines){
    const line = raw.trim();
    if(!line){ closeList(); continue; }

    /* ------------ separador "---" ------------------------- */
    if (/^---+$/.test(line)){ closeList(); html += "<hr>"; continue; }

/* ------------ cabe√ßalhos via negrito inteiro ------------------------------ */
// toda linha que for apenas **texto** vira <h3>texto</h3>
if (/^<strong>.*<\/strong>$/.test(line)) {
  closeList();
  html += `<h3>${line.replace(/^<strong>|<\/strong>$/g,"")}</h3>`;
  continue;
}
/* ------------ cabe√ßalhos markdown ## / ### ------------------------------ */
if (/^##\s+/.test(line) || /^###\s+/.test(line)) {
  closeList();
  const lvl = line.startsWith("###") ? "h4" : "h3";
  html += `<${lvl}>${line.replace(/^###?\s+/,"")}</${lvl}>`;
  continue;
}

    /* ------------ bullet list "- " ----------------------- */
    if (/^\-\s+/.test(line)){
      if(list!=="ul"){ closeList(); html+="<ul>"; list="ul"; }
      html += `<li>${line.slice(2).trim()}</li>`;
      continue;
    }

    /* ------------ numbered list "1. " -------------------- */
    if (/^\d+\.\s+/.test(line)){
      if(list!=="ol"){ closeList(); html+="<ol>"; list="ol"; }
      html += `<li>${line.replace(/^\d+\.\s+/,"")}</li>`;
      continue;
    }

    /* ------------ par√°grafo normal ----------------------- */
    closeList();
    html += `<p>${line}</p>`;
  }
  closeList();
  return html;
}

    /* ---------- TinyMCE ---------- */
    tinymce.init({
      selector: '#editor',
      height: 500,
      menubar: false,
      toolbar: 'undo redo | bold italic underline | bullist numlist',
      branding: false,
      automatic_uploads: true,
      content_style: `body{font-family:Helvetica,Arial,sans-serif;font-size:12pt;line-height:1.4;text-align:justify;padding:20px;}
p,li{margin:0 0 10px 0;}
img{max-width:100%;height:auto;}`,
      setup: function (editor) {
        editor.on('init', function () {
          const presetParam = new URLSearchParams(window.location.search).get('preset');
          if (presetParam) {
            const key   = 'auto_' + presetParam;
            const saved = localStorage.getItem(key);

            if (saved) {
              editor.setContent(saved.replace(/\n/g, '<br>')); // converte \n em <br>
              console.log('Conte√∫do aplicado ao TinyMCE (' + key + '):',
                          saved.slice(0,120) + (saved.length>120?'‚Ä¶':''));
              localStorage.removeItem(key);
            } else {
              console.log('Nenhum conte√∫do encontrado para', key);
            }
          }
        });
        // Justifica todo novo par√°grafo inserido
        editor.on('NodeChange', function(e){
          if(e && e.element && e.element.nodeName==='P'){
            e.element.style.textAlign = 'justify';
            e.element.style.fontSize  = '12pt';
          }
        });
      }
    });



    /* ---------- Salvar documento (PDF + Firestore) ---------- */
    window.salvarDocumento = async function () {
      const tipo        = document.getElementById("tipo").value;
      const htmlContent = tinymce.get("editor").getContent().trim();
      // Remove an initial empty paragraph if present
      const cleanedHtmlContent = htmlContent.replace(/^\s*<p><br><\/p>/i, '');

      /* texto bruto (mant√©m quebras de linha) */
      const rawText     = tinymce.get("editor").getContent({ format:"text" }).trim();

      /* vers√£o compacta (sem quebras) usada para salvar no Firestore */
      const plainText   = rawText.replace(/\s+/g, " ").trim();

      if (!pacienteId || !tipo || !htmlContent || !medicoId) {
        alert("Preencha o conte√∫do e escolha uma pasta.");
        return;
      }
      const ok = confirm(`Salvar documento na pasta "${tipo.toUpperCase()}"?`);
      if (!ok) return;    // usu√°rio cancelou

      try {
        const docRef = doc(db,"pacientes",pacienteId);
        const snap   = await getDoc(docRef);
        if (!snap.exists()) throw new Error("Paciente n√£o encontrado.");

        const dados       = snap.data();
        const arrayAtual  = Array.isArray(dados[tipo]) ? dados[tipo] : [];
        arrayAtual.push(plainText);
        await updateDoc(docRef,{ [tipo]: arrayAtual });

        /* -------- nomePDF: tema-dia-mes-ano_hora -------- */
        let nomePDF   = "";
        let dataParte = "";
        let horaParte = "";

        const headerMatch = rawText.match(
          /^(?:#+\s*)?(\d{2})\/(\d{2})\/(\d{4})\s+(\d{2}:\d{2})\s*[‚Äì‚Äî-]\s*(.+)$/m
        ); // 1=dia 2=m√™s 3=ano 4=hora 5=tema

        if (headerMatch && headerMatch[5]) {
          const dia       = headerMatch[1];
          const mes       = headerMatch[2];
          const ano       = headerMatch[3];
          horaParte       = headerMatch[4].replace(":", "-");
          /* Tema: pega s√≥ at√© primeiro ponto/‚ÄúS ‚Äù ou 6 palavras, m√°x 50 chars */
          let temaParte = headerMatch[5]
                            .split(/[.;:‚Äì‚Äî-]/)[0]     // corta na 1¬™ pontua√ß√£o / tra√ßo
                            .trim()
                            .split(/\s+/)
                            .slice(0, 6)             // no m√°x 6 palavras
                            .join("-")
                            .toLowerCase()
                            .replace(/[^\w\-]/g, "");
          temaParte = temaParte.slice(0, 50);         // m√°x 50 caracteres
          dataParte = `${dia}-${mes}-${ano}`;         // DD-MM-AAAA
          nomePDF   = `${temaParte}_${dataParte}_${horaParte}.pdf`;
        } else {
          /* fallback: tipo-dia-mes-ano_hora ‚Äî usando fuso S√£o¬†Paulo */
          const agoraSP = new Date(
            new Date().toLocaleString("en-US", { timeZone: "America/Sao_Paulo" })
          );
          const dia       = String(agoraSP.getDate()).padStart(2, "0");
          const mes       = String(agoraSP.getMonth() + 1).padStart(2, "0");
          const ano       = agoraSP.getFullYear();
          horaParte       = `${String(agoraSP.getHours()).padStart(2,"0")}-${String(
            agoraSP.getMinutes()
          ).padStart(2,"0")}`;
          dataParte = `${dia}-${mes}-${ano}`;
          nomePDF   = `${tipo}_${dataParte}_${horaParte}.pdf`;
        }

        /* ----- CSS inline para evitar corte de linhas ----- */
        const styleFix = `
    <style>
      body,p,li{font-size:12pt;line-height:1.4;text-align:justify;}
      h1,h2,h3,h4,h5,h6,p,li{page-break-inside:avoid;}
    </style>`;

        // Obter nomes
        let nomePaciente = pacienteId;   // fallback = UID
        let nomeMedico   = medicoId;     // fallback = UID

        try {
          /* ------------ nome do paciente ------------ */
          const pacSnap = await getDoc(doc(db, "pacientes", pacienteId));
          if (pacSnap.exists()) {
            const identPac = pacSnap.data().identificacao;           // array?
            if (Array.isArray(identPac) && identPac[0]?.nome) {
              nomePaciente = identPac[0].nome;
            }
          }

          /* ------------ nome do m√©dico --------------- */
          const medSnap = await getDoc(doc(db, "medicos", medicoId));
          if (medSnap.exists()) {
            const identMed = medSnap.data().identificacao;           // array?
            if (Array.isArray(identMed) && identMed[0]?.nome) {
              nomeMedico = identMed[0].nome;
            }
          }
        } catch (err) {
          console.warn("Falha ao obter nomes:", err); // mant√©m UID se der erro
        }

        /* ---- Gera√ß√£o de PDF no back-end ---- */
        const respPDF = await fetch(`${API_BASE}/generate_pdf/`, {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({
            template: (tipo === "tratamento") ? "tratamento" : "geral",
            paciente_id: pacienteId,
            tipo: tipo,
            nome_pdf: nomePDF,
            paciente: nomePaciente,
            medico:   nomeMedico,
            data:     dataParte.replace(/-/g,"/"),
            hora:     horaParte.replace("-",":"),
            conteudo: cleanedHtmlContent
          })
        });
        if (!respPDF.ok) throw new Error(await respPDF.text());
        const { url } = await respPDF.json();
        window.open(url, "_blank");  // abre o PDF j√° salvo no Storage
        alert("Documento salvo com sucesso!");
        window.location.href = "paciente_view.html";

      } catch (error) {
        console.error(error);
        alert("Erro ao salvar.");
      }
    };

    /* ---------- Primeira an√°lise do Clinbot ---------- */
    window.clinbotPrimeiraAnalise = async function () {
      const tipo        = document.getElementById("tipo").value;
      const htmlContent = tinymce.get("editor").getContent().trim();
      const plainText   = tinymce.get("editor").getContent({ format:"text" }).replace(/\s+/g," ").trim();

      if (!pacienteId || !tipo || !htmlContent || !medicoId) {
        alert("Preencha o conte√∫do e escolha uma pasta.");
        return;
      }

      /* Salvar TXT no Firestore (sem sair) */
      try {
        const docRef = doc(db,"pacientes",pacienteId);
        const snap   = await getDoc(docRef);
        if (!snap.exists()) throw new Error("Paciente n√£o encontrado.");
        const dados       = snap.data();
        const arrayAtual  = Array.isArray(dados[tipo]) ? dados[tipo] : [];
        arrayAtual.push(plainText);
        await updateDoc(docRef, { [tipo]: arrayAtual });
      } catch (e) {
        console.error("Erro ao salvar texto:", e);
        alert("Erro ao salvar texto antes do Clinbot.");
        return;
      }


      /* Monta mensagens */
      conversation.length = 0; // zera
      conversation.push({ role:"user", content: plainText });

      await chamarOpenAI(); // faz chamada e exibe chat
      /* Ap√≥s retorno, exibe √°rea de pergunta */
      document.getElementById("clinbotQuestion").hidden = false;
      document.getElementById("clinbotAskBtn").hidden   = false;
    };

    /* ---------- Perguntar depois ---------- */
    window.clinbotPerguntar = async function () {
      const perguntaEl = document.getElementById("clinbotQuestion");
      const pergunta   = perguntaEl.value.trim();
      if (!pergunta) return;
      conversaLog("user", pergunta);
      conversation.push({ role:"user", content: pergunta });
      perguntaEl.value = "";
      await chamarOpenAI();
    };

    /* ---------- Fun√ß√£o comum para chamar a OpenAI (Clinbot) ---------- */
async function chamarOpenAI() {
  const chatDiv = document.getElementById("clinbotChat");
  chatDiv.hidden = false;
  conversaLog("assistant", "‚è≥ Pensando...");

  try {
    /* envie o array completo `conversation` */
    const resposta = await fetch(`${API_BASE}/clinbot/`, {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({ conversation })          // üîë hist√≥rico inteiro
    });

    if (!resposta.ok) throw new Error(`HTTP ${resposta.status}`);

    const data          = await resposta.json();
    const respostaBruta = (data.reply || "").trim();

    chatDiv.lastChild.innerHTML = "ü§ñ " + formatAssistant(respostaBruta);
    conversation.push({ role: "assistant", content: respostaBruta });

  } catch (e) {
    console.error("Erro no Clinbot:", e);
    chatDiv.lastChild.textContent = "‚ùå Erro ao obter resposta do Clinbot.";
  }
}

/* ---------- Helper para exibir conversa ---------- */
function conversaLog(role, texto){
  const chatDiv = document.getElementById("clinbotChat");
  const msg     = document.createElement("div");
  msg.className = role === "user" ? "user" : "assistant";

  if(role === "assistant"){
    msg.innerHTML = "ü§ñ " + formatAssistant(texto);
  }else{
    msg.textContent = `üë®‚Äç‚öïÔ∏è ${texto}`;
  }
  chatDiv.appendChild(msg);
  chatDiv.scrollTop = chatDiv.scrollHeight;
}

    /* ---------- Voltar ---------- */
    window.voltar = () => window.location.href = "paciente_view.html";

/* ================================================================= */
/* ===            √ÅUDIO  ‚Äì  GRAVAR ‚Ä¢ TRANSCRIBIR ‚Ä¢ SOAP           === */
/* ================================================================= */

/* ---------- Iniciar grava√ß√£o ---------- */
let chunkTimer      = null;   // reinicia a cada 3 s
let currentSeconds  = 0;

/* trata cada blob recebido */
async function processBlob(blob){
  if (recordingDone) return;          // <‚Äî se j√° finalizei, ignora
  const texto = await transcreverAudio(blob);
  if (!texto) return;

  /* mostra bloco no topo da aba lateral */
  const painel = document.getElementById("transcriptionContent");
  const bloco  = document.createElement("p");
  bloco.textContent = texto.trim();
  painel.insertBefore(bloco, painel.firstChild);
  painel.scrollTop = 0;

  /* acumula e gera SOAP a cada 10 transcri√ß√µes */
  transcriptChunks.push(texto.trim());
  summaryCounter++;
  if (summaryCounter % 10 === 0) {
    const soap = await gerarNotaSOAP(transcriptChunks.join(" "));
    if (soap) {
      const editor = tinymce.get('editor');
      const atual = editor.getContent();
      // Format interim SOAP content
      const interimHtml = `<div id="soapGerado">${formatAssistant(soap)}</div>`;
      let novoConteudo;
      if (atual.includes('id="soapGerado"')) {
        // Replace previous interim or final SOAP block
        novoConteudo = atual.replace(
          /<div id="soapGerado"[\s\S]*?<\/div>/,
          interimHtml
        );
      } else {
        // Append interim SOAP below existing content
        novoConteudo = atual + '<p><br></p>' + interimHtml;
      }
      editor.setContent(novoConteudo);
    }
  }
}

window.iniciarGravacao = async () => {
  try{
    const stream   = await navigator.mediaDevices.getUserMedia({ audio:true });
    const mimeType = MediaRecorder.isTypeSupported("audio/webm;codecs=opus")
                     ? "audio/webm;codecs=opus" : "audio/ogg;codecs=opus";
    mediaRecorder  = new MediaRecorder(stream,{ mimeType });

    keepCycling = true;           // grava√ß√£o ativa ‚Üí permite reiniciar ciclos
    /* reinicia o gravador a cada 10 s para garantir cabe√ßalho v√°lido */
    function startCycle(){
      mediaRecorder.start();
      chunkTimer = setTimeout(()=>{
        if(!isPaused) mediaRecorder.stop();      // dispara ondataavailable
      },10000);
    }

    mediaRecorder.ondataavailable = e=>{
      /* Processa chunk somente se grava√ß√£o n√£o estiver pausada */
      if(e.data && e.data.size && !isPaused){
        processBlob(e.data);
      }
    };

    mediaRecorder.onstop = () => {
  if (keepCycling && !isPaused) startCycle();   // s√≥ reinicia se ainda gravando
};

    /* -------- UI -------- */
    document.getElementById("recordBtn").hidden  = true;
    document.getElementById("stopBtn").hidden    = false;
    document.getElementById("pauseBtn").hidden   = false;
    document.getElementById("resumeBtn").hidden  = true;
    document.getElementById("transcribePanel").hidden = false;
    document.getElementById("transcriptionContent").innerHTML = "";
    transcriptChunks.length = 0;

    /* cron√¥metro */
    currentSeconds = 0;
    const label = document.getElementById("tempoLabel");
    cronometro = setInterval(()=>{
      currentSeconds++;
      label.textContent =
        `${String(Math.floor(currentSeconds/60)).padStart(2,"0")}:`+
        `${String(currentSeconds%60).padStart(2,"0")}`;
    },1000);

    startCycle();                                // inicia grava√ß√£o

  }catch(err){
    console.error(err);
    alert("N√£o foi poss√≠vel acessar o microfone.");
  }
};

/* ---------- Pausar ---------- */
window.pausarGravacao = () => {
  if(!mediaRecorder || mediaRecorder.state!=="recording") return;

  /* Interrompe contagem do cron√¥metro */
  clearInterval(cronometro);

  /* Interrompe timer que for√ßaria mediaRecorder.stop() */
  clearTimeout(chunkTimer);

  /* Quando o recorder de fato parar, marcamos pausa */
  const onStopOnce = () => {
    isPaused = true;                // marca pausa s√≥ DEPOIS do √∫ltimo chunk
    mediaRecorder.removeEventListener("stop", onStopOnce);
  };
  mediaRecorder.addEventListener("stop", onStopOnce);

  /* Garante que o √∫ltimo chunk seja emitido */
  mediaRecorder.stop();

  /* Ajusta UI */
  document.getElementById("pauseBtn").hidden  = true;
  document.getElementById("resumeBtn").hidden = false;
};

/* ---------- Retomar ---------- */
window.retomarGravacao = () => {
  if (!mediaRecorder || !isPaused) return;

  isPaused = false;           // permite processar novos chunks

  /* Reinicia cron√¥metro mantendo tempo j√° decorrido */
  cronometro = setInterval(() => {
    currentSeconds++;
    document.getElementById("tempoLabel").textContent =
      `${String(Math.floor(currentSeconds / 60)).padStart(2, "0")}:` +
      `${String(currentSeconds % 60).padStart(2, "0")}`;
  }, 1000);

  /* Se o MediaRecorder estiver inativo, inicie; caso contr√°rio, apenas reinicie o timer */
  if (mediaRecorder.state === "inactive") {
    mediaRecorder.start();
  }

  /* (Re)inicia o timer para for√ßar split de chunks */
  clearTimeout(chunkTimer);
  chunkTimer = setTimeout(() => { mediaRecorder.stop(); }, 10000);

  /* Ajusta UI */
  document.getElementById("pauseBtn").hidden  = false;
  document.getElementById("resumeBtn").hidden = true;
};

/* ---------- Parar grava√ß√£o ---------- */
window.pararGravacao = () => {
  
  clearTimeout(chunkTimer);
  if(mediaRecorder && mediaRecorder.state!=="inactive") mediaRecorder.stop();
  finalizarGravacao();
};

/* ---------- Finalizar grava√ß√£o (stop) ---------- */
async function finalizarGravacao(){
  recordingDone = true;
  // Para de reiniciar ciclos
  keepCycling = false;
  // p√°ra o cron√¥metro
  clearInterval(cronometro);
  document.getElementById("tempoLabel").textContent = "";
  // restaura bot√µes
  document.getElementById("recordBtn").hidden  = false;
  document.getElementById("stopBtn").hidden    = true;
  document.getElementById("pauseBtn").hidden   = true;
  document.getElementById("resumeBtn").hidden  = true;
  document.getElementById("transcribePanel").hidden = true;

  if (transcriptChunks.length) {
    /// Texto completo da consulta
    const fullText = transcriptChunks.join(" ");

    // Exibe o status SOAP
    const statusEl = document.getElementById("soapStatus");
    statusEl.style.display = "block";

    // Gera a √∫ltima vers√£o SOAP
    const soap = await gerarNotaSOAP(fullText);

    if (soap) {
      /* Formata e encapsula o SOAP em um bloco identific√°vel */
      const htmlResumo = `<div id="soapGerado">${formatAssistant(soap)}</div>`;

      const editor = tinymce.get("editor");
      const atual  = editor.getContent();

      let novoConteudo;

      /* se j√° existir um SOAP anterior, substitui; sen√£o, acrescenta abaixo */
      if (atual.includes('id="soapGerado"')) {
        novoConteudo = atual.replace(
          /<div id="soapGerado"[\s\S]*?<\/div>/,
          htmlResumo
        );
      } else {
        novoConteudo = atual + '<p><br></p>' + htmlResumo;
      }

      editor.setContent(novoConteudo);
      statusEl.style.display = "none";
    }

    // --- NOVO: categoriza√ß√£o autom√°tica via backend ---
    const categoriasJSON = await categorizarTranscricao(fullText);
    if (categoriasJSON) {
      ["tratamento", "exame", "documento"].forEach(cat => {
        if (categoriasJSON[cat] && categoriasJSON[cat].length) {
          const conteudo = categoriasJSON[cat].join("\n\n");
          console.log('Salvando em', "auto_"+cat, '‚Üí',
            conteudo.slice(0,120) + (conteudo.length>120?'‚Ä¶':''));
          localStorage.setItem("auto_" + cat, conteudo);          abrirAutoTab(cat);
        }
      });
    }

    await window.clinbotPrimeiraAnalise();
  }
}

    /* ---------- Transcri√ß√£o via backend ---------- */
async function transcreverAudio(blob) {
  const formData = new FormData();
  const ext  = blob.type.includes("ogg") ? "ogg" : "webm";
  formData.append("file", new File([blob], `chunk.${ext}`, { type: blob.type }));
  try {
    const resp = await fetch(`${API_BASE}/transcribe/`, {
      method: "POST",
      body: formData,
    });
    if (!resp.ok) throw new Error(await resp.text());
    const data = await resp.json();
    return data.transcript || null;
  } catch (e) {
    console.error("Erro na transcri√ß√£o:", e);
    return null;
  }
}

    /* ---------- Gera√ß√£o da nota SOAP ---------- */
    async function gerarNotaSOAP(transcricao) {
      try {
        const resp = await fetch(`${API_BASE}/summarize/`, {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({ transcript: transcricao }),
        });
        if (!resp.ok) throw new Error(await resp.text());
        const data = await resp.json();
        return data.soap || null;
      } catch (e) {
        console.error("Erro ao gerar SOAP:", e);
        return null;
      }
    }

  /* ---------- Categoriza√ß√£o via backend ---------- */
async function categorizarTranscricao(texto) {
  try {
    const resp = await fetch(`${API_BASE}/categorize/`, {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({ transcript: texto })
    });
    if (!resp.ok) throw new Error(await resp.text());
    return await resp.json();          // {tratamento:[], exame:[], documento:[]}
  } catch (e) {
    console.error("Erro na categoriza√ß√£o:", e);
    return null;
  }
}

  </script>

  
</body>
</html>